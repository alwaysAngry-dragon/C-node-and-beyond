1. Stream Creation (fileHandle.createWriteStream())
When you call:

const writeStream = fileHandle.createWriteStream();

  Node.js:

    Creates a WriteStream instance linked to the file descriptor.

    Initializes an internal buffer (default size: 16KB, configurable via highWaterMark).

    Sets up event listeners (drain, error, finish, etc.).

    Does not write to disk yet - just prepares the stream structure.

2. Writing Data (writeStream.write())
When you call:

writeStream.write(Buffer.from(` ${i} `, "utf-8"));

    Node.js:

      Copies your data into the stream's internal buffer (in memory).

      Checks if buffer is full (exceeds highWaterMark):

      If not full: Returns true (data is buffered, not yet on disk).

      If full: Returns false (backpressure - you should pause writing).

      Asynchronously schedules disk writes via libuv (Node's I/O layer).

3. Behind-the-Scenes: How Data Reaches Disk

    Libuv's event loop detects pending writes in the stream's buffer.

    OS-level file writing begins (non-blocking, handled by the OS kernel).

    Data is flushed in chunks (not necessarily one write() = one disk write).

    Buffer empties as writes complete, emitting drain if previously full.

4. Stream Closing (writeStream.end())
  When you call:

  await writeStream.end();

    Node.js:

      Flushes remaining buffered data to disk.

      Closes the file descriptor (unless autoClose: false).

      Emits finish event when all data is safely written.



Data Flow in fs.createWriteStream()

    writeStream.write(data) is called

    1. Data is copied into Node.js's internal buffer (in RAM).

    2. Default buffer size (highWaterMark) = 16KB (can be configured).

    3. Buffer fills up quickly (faster than disk I/O)

    4. Since JavaScript executes much faster than disk writes, the buffer fills up quickly.

    5. Once the buffer reaches highWaterMark, write() returns false (backpressure signal).

    6. LibUV schedules disk writes

    7. Node.js (via libuv) asynchronously flushes the buffer to disk.

    8. The OS handles the actual file write (non-blocking).

    9. Buffer drains, allowing more writes

    10. When enough data is written to disk, the buffer empties.

    11. Node.js emits a 'drain' event, signaling it’s safe to write more.


Time  | JavaScript (Fast)          | Disk I/O (Slow)            | Buffer State Max 16KB(default)
------|----------------------------|----------------------------|---------------
t=0ms | write("A") → buffer = [A]  |                            | [A]
t=1ms | write("B") → buffer = [A,B]| OS starts writing "A"      | [B] (A in flight)
t=2ms | write("C") → returns false | Still writing "A"          | [B,C] (backpressure)
t=5ms | (paused)                   | "A" done → emits 'drain'   | [C] (B now in flight)
t=6ms | write("D") → buffer = [C,D]|                            | [D] (C in flight)
